# will remove this at the end


# image processing
def grayscale_image(image, target):
    # The luminosity of images depend more greatly on the green component more
    # than any other color, at least when it comes to human vision.
    # This is why this blend of components looks better than most
    # traditional true b/w images (i.e, 0.33, 0.33, 0.33)

    # TODO might just get rid of this whole thing in lieu of Image.convert('L')

    r_component = 0.30
    g_component = 0.59
    b_component = 0.11

    raw_image = Image.open(image).convert('RGB')
    raw_image.convert('L').save('better_gray.jpg')
    raw_image.save('normal.jpg')
    image_array = np.array(raw_image)
    # print(image_array[1][1][0])
    for i in range(len(image_array)):
        for j in range(len(image_array[0])):
            image_array[i][j] = r_component * image_array[i][j][0] \
                                + g_component * image_array[i][j][1] \
                                + b_component * image_array[i][j][2]
    #  TODO compress three-value pixel value into one value
    #       This would save a bit of memory but at the moment isn't worth the hassle
    grayscale = Image.fromarray(image_array)
    grayscale.save(target)  # TODO return image instead of saving
    return grayscale


# audio processing
# plt.show()

sampling_rate = 44100
freq = 1000
channels = 1
sample_width = 2
x = np.arange(sampling_rate)

# Sine
y = 16384 * np.sin(2 * np.pi * freq * x / sampling_rate)
# y = audio_level * sin(2pi * freq * x / sampling_rate)
# I found 16384 is a good level for 32 bit integers.
# Anything higher than 40,000 creates distortion

# Square
# y = 100 * sg.square(2 * np.pi * freq * x / sampling_rate)

# Square with duty cycle
# y = 100 * sg.square(2 * np.pi * freq * x / sampling_rate, duty=0.9)

# Sawtooth
# y = 100 * sg.sawtooth(2 * np.pi * freq * x / sampling_rate)

wav = wave.open('test.wav', 'wb')
wav.setnchannels(channels)
wav.setsampwidth(sample_width)
wav.setframerate(sampling_rate)
print(wav.getnframes())

for i in y:
    wav.writeframesraw(struct.pack('i', int(i)))
print(wav.getnframes())
wav.close()


# wave.open('test.wav', mode='rb')

# Use command:
# play -t raw -r 44.1k -e signed -b 8 -c 1 test.wav


# bw practice


def convert_image(image_path):
    raw_img = Image.open(image_path)
    raw_img.load()
    data = np.asarray(raw_img, dtype=int)
    return data


def save_image(npdata, out_file):
    # img = Image.fromarray(np.asanyarray(np.clip(npdata, 0, 255), dtype='int'), 'L')
    img = Image.frombuffer(npdata.size, npdata)
    img.save(out_file)


array = convert_image('../data/flower.gray.jpg')
# for i in array:
#     for j in array[0]:
#         array[i][j] = int(array[i][j])/4
plt.figure(1)
plt.title('Image')
compressor_value = 128
array = array/compressor_value
array = np.around(array, 0)
plt.imshow(array, cmap='gray', interpolation='nearest', vmin=0, vmax=255/compressor_value)
plt.imsave('../data/flower.gray.compressed.bmp', array, cmap='gray', vmin=0, vmax=255/compressor_value)
array = array.flatten()
print(array)
print(len(array))
# plt.show()