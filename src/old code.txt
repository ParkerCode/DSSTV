# will remove this at the end


# image processing
def grayscale_image(image, target):
    # The luminosity of images depend more greatly on the green component more
    # than any other color, at least when it comes to human vision.
    # This is why this blend of components looks better than most
    # traditional true b/w images (i.e, 0.33, 0.33, 0.33)

    # TODO might just get rid of this whole thing in lieu of Image.convert('L')

    r_component = 0.30
    g_component = 0.59
    b_component = 0.11

    raw_image = Image.open(image).convert('RGB')
    raw_image.convert('L').save('better_gray.jpg')
    raw_image.save('normal.jpg')
    image_array = np.array(raw_image)
    # print(image_array[1][1][0])
    for i in range(len(image_array)):
        for j in range(len(image_array[0])):
            image_array[i][j] = r_component * image_array[i][j][0] \
                                + g_component * image_array[i][j][1] \
                                + b_component * image_array[i][j][2]
    #  TODO compress three-value pixel value into one value
    #       This would save a bit of memory but at the moment isn't worth the hassle
    grayscale = Image.fromarray(image_array)
    grayscale.save(target)  # TODO return image instead of saving
    return grayscale


# audio processing
# plt.show()

sampling_rate = 44100
freq = 1000
channels = 1
sample_width = 2
x = np.arange(sampling_rate)

# Sine
y = 16384 * np.sin(2 * np.pi * freq * x / sampling_rate)
# y = audio_level * sin(2pi * freq * x / sampling_rate)
# I found 16384 is a good level for 32 bit integers.
# Anything higher than 40,000 creates distortion

# Square
# y = 100 * sg.square(2 * np.pi * freq * x / sampling_rate)

# Square with duty cycle
# y = 100 * sg.square(2 * np.pi * freq * x / sampling_rate, duty=0.9)

# Sawtooth
# y = 100 * sg.sawtooth(2 * np.pi * freq * x / sampling_rate)

wav = wave.open('test.wav', 'wb')
wav.setnchannels(channels)
wav.setsampwidth(sample_width)
wav.setframerate(sampling_rate)
print(wav.getnframes())

for i in y:
    wav.writeframesraw(struct.pack('i', int(i)))
print(wav.getnframes())
wav.close()


# wave.open('test.wav', mode='rb')

# Use command:
# play -t raw -r 44.1k -e signed -b 8 -c 1 test.wav

